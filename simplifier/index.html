<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Steve's Expression Simplifier</title>

	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
	<link rel="stylesheet"
		href="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.css">
	<script
		src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
	<script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathquill/0.10.1/mathquill.js"></script>

	<style>
		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
			background: #ffffff;
			padding: 40px 20px;
		}

		.container {
			max-width: 700px;
			margin: 0 auto;
		}

		h2 {
			font-size: 28px;
			font-weight: 600;
			color: #1f2937;
			margin: 0 0 40px 0;
		}

		button {
			padding: 12px 24px;
			font-size: 14px;
			font-weight: 500;
			background: #2563eb;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			transition: background-color 0.2s;
		}

		button:hover {
			background: #1d4ed8;
		}

		button:active {
			background: #1e40af;
		}

		.label {
			font-size: 11px;
			font-weight: 700;
			color: #9ca3af;
			margin-bottom: 12px;
			text-transform: uppercase;
			letter-spacing: 0.8px;
		}

		.section {
			margin-bottom: 32px;
		}

		.input-container {
			margin-bottom: 32px;
		}

		#output {
			background: #f3f4f6;
			padding: 20px;
			border-radius: 4px;
			font-family: 'Courier New', monospace;
			font-size: 14px;
			color: #1f2937;
		}

		.decimal-value {
			color: #9ca3af;
			font-size: 12px;
			margin-top: 8px;
			font-family: 'Courier New', monospace;
		}
	</style>
</head>

<body>

<div class="container">
	<h2>Steve's Expression Simplifier</h2>

	<div class="section">
		<div class="label">Input</div>
		<div class="input-container">
			<span id="input" class="math-input">\frac{\sqrt{3}}{3}\cdot\frac{2\cdot 6^{5/2}}{5}-4\cdot 6^{3/2}</span>
		</div>
		<div class="decimal-value" id="inputDecimal"></div>
	</div>

	<button onclick="simplify()" style="margin-top: 20px;">Simplify</button>

	<div class="section" style="margin-top: 32px;">
		<div class="label">Exact Result</div>
		<div id="outputRender" class="math-display"></div>
		<div class="decimal-value" id="outputDecimal"></div>
	</div>
</div>

	<script>
		var MQ;
		var mathField;

		$(function() {
			setTimeout(function() {
				try {
					MQ = MathQuill.getInterface(2);
					var inputEl = document.getElementById('input');
					if (inputEl) {
						mathField = MQ.MathField(inputEl);
					}
				} catch(e) {
					console.error('Error initializing MathQuill:', e);
				}
			}, 100);
		});

		function simplify() {
			const latex = mathField ? mathField.latex() : '';
			
			console.log("Input LaTeX:", latex);

			try {
				const parsedInput = parseLatex(latex);
				console.log("Parsed input:", parsedInput);
				
				let inputDecimal = 0;
				if (parsedInput instanceof AlgebraicExpr) {
					inputDecimal = algebraicToDecimal(parsedInput);
				} else if (parsedInput.coeffs) {
					inputDecimal = radicalToDecimal(parsedInput);
				}
				console.log("Input decimal:", inputDecimal);
				document.getElementById("inputDecimal").textContent = '= ' + inputDecimal.toFixed(10);
				
				// Evaluate symbolically and get both the AlgebraicExpr object and LaTeX string
				const result = evaluateSymbolicFull(latex);
				console.log("Result object:", result);
				console.log("Result LaTeX:", result.latex);
				katex.render(result.latex, document.getElementById("outputRender"), { throwOnError: false });
				
				// Compute decimal of the result
				let outputDecimal = 0;
				if (result.expr instanceof AlgebraicExpr) {
					outputDecimal = algebraicToDecimal(result.expr);
				} else if (result.expr.coeffs) {
					outputDecimal = radicalToDecimal(result.expr);
				}
				console.log("Output decimal:", outputDecimal);
				document.getElementById("outputDecimal").textContent = '= ' + outputDecimal.toFixed(10);
			} catch(e) {
				console.error('Error:', e);
				document.getElementById("outputRender").textContent = 'Error: ' + e.message;
				document.getElementById("inputDecimal").textContent = '';
				document.getElementById("outputDecimal").textContent = '';
			}
		}
		
		function evaluateSymbolicFull(latex) {
			try {
				const expr = parseLatex(latex);
				return {
					expr: expr,
					latex: expr.toLatex()
				};
			} catch(e) {
				throw new Error(e.message);
			}
		}
		
		function evaluateSymbolic(latex) {
			const result = evaluateSymbolicFull(latex);
			return result.latex;
		}

		function gcd(a, b) {
			a = Math.abs(a);
			b = Math.abs(b);
			while (b !== 0) {
				let temp = b;
				b = a % b;
				a = temp;
			}
			return a;
		}

		// ========== EXACT ARITHMETIC SYSTEM ==========
		// RationalFunction: represents numerator / denominator where both are polynomials
		class RationalFunction {
			constructor(numerator, denominator) {
				this.numerator = numerator;   // AlgebraicExpr
				this.denominator = denominator; // AlgebraicExpr
			}
			
			static of(expr) {
				if (expr instanceof RationalFunction) return expr;
				if (expr instanceof AlgebraicExpr) {
					return new RationalFunction(expr, AlgebraicExpr.ofNumber(1));
				}
				throw new Error('Cannot convert to RationalFunction');
			}
			
			add(other) {
				other = RationalFunction.of(other);
				// a/b + c/d = (ad + bc) / (bd)
				const newNum = this.numerator.mul(other.denominator).add(other.numerator.mul(this.denominator));
				const newDen = this.denominator.mul(other.denominator);
				return new RationalFunction(newNum, newDen);
			}
			
			sub(other) {
				other = RationalFunction.of(other);
				// a/b - c/d = (ad - bc) / (bd)
				const newNum = this.numerator.mul(other.denominator).sub(other.numerator.mul(this.denominator));
				const newDen = this.denominator.mul(other.denominator);
				return new RationalFunction(newNum, newDen);
			}
			
			mul(other) {
				other = RationalFunction.of(other);
				const newNum = this.numerator.mul(other.numerator);
				const newDen = this.denominator.mul(other.denominator);
				return new RationalFunction(newNum, newDen);
			}
			
			pow(n) {
				let result = RationalFunction.of(AlgebraicExpr.ofNumber(1));
				for (let i = 0; i < n; i++) {
					result = result.mul(this);
				}
				return result;
			}
			
			toLatex() {
				const numLatex = this.numerator.toLatex();
				const denLatex = this.denominator.toLatex();
				
				if (denLatex === '1') return numLatex;
				return '\\frac{' + numLatex + '}{' + denLatex + '}';
			}
		}
		
		// AlgebraicExpr: represents polynomial expressions with variables like x, y, etc.
		// Format: { varName: { exponent: Rational coefficient, ... }, ... }
		// E.g., 2x^2 + 3x + 1 is stored as { x: { 2: 2, 1: 3, 0: 1 } }
		class AlgebraicExpr {
			constructor(terms = {}) {
				this.terms = {}; // { varName: { exponent: Rational, ... }, ... }
				for (let varName in terms) {
					this.terms[varName] = {};
					for (let exp in terms[varName]) {
						if (terms[varName][exp] && terms[varName][exp].num !== 0) {
							this.terms[varName][exp] = terms[varName][exp];
						}
					}
					if (Object.keys(this.terms[varName]).length === 0) {
						delete this.terms[varName];
					}
				}
			}
			
			static ofRational(r) {
				const expr = new AlgebraicExpr();
				expr.terms.constant = { 0: r };
				return expr;
			}
			
			static ofNumber(n) {
				if (typeof n === 'number') n = new Rational(n);
				const expr = new AlgebraicExpr();
				expr.terms.constant = { 0: n };
				return expr;
			}
			
			static ofVariable(varName, exponent = 1) {
				const expr = new AlgebraicExpr();
				expr.terms[varName] = {};
				expr.terms[varName][exponent] = new Rational(1);
				return expr;
			}
			
			isConstant() {
				return Object.keys(this.terms).length === 0;
			}
			
			getConstant() {
				if (this.terms.constant && this.terms.constant[0]) {
					return this.terms.constant[0];
				}
				return new Rational(0);
			}
			
			add(other) {
				if (typeof other === 'number') other = AlgebraicExpr.ofNumber(other);
				const result = new AlgebraicExpr(this.terms);
				for (let varName in other.terms) {
					if (!result.terms[varName]) {
						result.terms[varName] = {};
					}
					for (let exp in other.terms[varName]) {
						result.terms[varName][exp] = (result.terms[varName][exp] || new Rational(0)).add(other.terms[varName][exp]);
						if (result.terms[varName][exp].num === 0) delete result.terms[varName][exp];
					}
					if (Object.keys(result.terms[varName]).length === 0) delete result.terms[varName];
				}
				return result;
			}
			
			sub(other) {
				if (typeof other === 'number') other = AlgebraicExpr.ofNumber(other);
				const result = new AlgebraicExpr(this.terms);
				for (let varName in other.terms) {
					if (!result.terms[varName]) {
						result.terms[varName] = {};
					}
					for (let exp in other.terms[varName]) {
						result.terms[varName][exp] = (result.terms[varName][exp] || new Rational(0)).sub(other.terms[varName][exp]);
						if (result.terms[varName][exp].num === 0) delete result.terms[varName][exp];
					}
					if (Object.keys(result.terms[varName]).length === 0) delete result.terms[varName];
				}
				return result;
			}
			
			mul(other) {
				if (typeof other === 'number') other = AlgebraicExpr.ofNumber(other);
				if (!(other instanceof AlgebraicExpr)) throw new Error('Cannot multiply with non-AlgebraicExpr');
				
				const result = new AlgebraicExpr();
				
				// Handle case when multiplying x * 1
				if (Object.keys(this.terms).length === 0) {
					return new AlgebraicExpr(other.terms);
				}
				if (Object.keys(other.terms).length === 0) {
					return new AlgebraicExpr(this.terms);
				}
				
				for (let var1 in this.terms) {
					for (let exp1 in this.terms[var1]) {
						for (let var2 in other.terms) {
							if (!result.terms[var2]) result.terms[var2] = {};
							for (let exp2 in other.terms[var2]) {
								let newExp, targetVar;
								if (var1 === var2) {
									newExp = parseInt(exp1) + parseInt(exp2);
									targetVar = var2;
								} else {
									if (var1 === 'constant') {
										newExp = parseInt(exp2);
										targetVar = var2;
									} else if (var2 === 'constant') {
										newExp = parseInt(exp1);
										targetVar = var1;
										if (!result.terms[targetVar]) result.terms[targetVar] = {};
									} else {
										throw new Error('Multivariate expressions not supported');
									}
								}
								
								const coeff = this.terms[var1][exp1].mul(other.terms[var2][exp2]);
								result.terms[targetVar][newExp] = (result.terms[targetVar][newExp] || new Rational(0)).add(coeff);
								if (result.terms[targetVar][newExp].num === 0) delete result.terms[targetVar][newExp];
							}
						}
					}
				}
				return result;
			}
			
			div(other) {
				throw new Error('Division of algebraic expressions not fully supported');
			}
			
			pow(n) {
				if (n === 0) return AlgebraicExpr.ofNumber(1);
				if (n === 1) return new AlgebraicExpr(this.terms);
				if (n < 0) return AlgebraicExpr.ofNumber(1).div(this.pow(-n));
				let result = AlgebraicExpr.ofNumber(1);
				for (let i = 0; i < n; i++) {
					result = result.mul(this);
				}
				return result;
			}
			
			toLatex() {
				if (Object.keys(this.terms).length === 0) return '0';
				const parts = [];
				for (let varName in this.terms) {
					const exps = Object.keys(this.terms[varName]).map(x => parseInt(x)).sort((a, b) => b - a);
					for (let exp of exps) {
						const coeff = this.terms[varName][exp];
						const sign = coeff.num < 0 ? '-' : '+';
						const absCoeff = Math.abs(coeff.num);
						const coeffStr = coeff.den === 1 ? absCoeff.toString() : '\\frac{' + absCoeff + '}{' + coeff.den + '}';
						
						if (exp === 0) {
							parts.push((parts.length === 0 ? (coeff.num < 0 ? '-' : '') : sign) + coeffStr);
						} else if (exp === 1) {
							if (absCoeff === 1 && coeff.den === 1) {
								parts.push((parts.length === 0 ? (coeff.num < 0 ? '-' : '') : sign) + varName);
							} else {
								parts.push((parts.length === 0 ? (coeff.num < 0 ? '-' : '') : sign) + coeffStr + varName);
							}
						} else {
							if (absCoeff === 1 && coeff.den === 1) {
								parts.push((parts.length === 0 ? (coeff.num < 0 ? '-' : '') : sign) + varName + '^{' + exp + '}');
							} else {
								parts.push((parts.length === 0 ? (coeff.num < 0 ? '-' : '') : sign) + coeffStr + varName + '^{' + exp + '}');
							}
						}
					}
				}
				return parts.join('');
			}
		}
		
		// Rational: exact fractions (numerator/denominator)
		class Rational {
			constructor(num, den = 1) {
				if (den === 0) throw new Error('Division by zero');
				const g = gcd(Math.abs(num), Math.abs(den));
				this.num = num / g;
				this.den = den / g;
				if (this.den < 0) {
					this.num = -this.num;
					this.den = -this.den;
				}
			}
			
			add(r) {
				if (!(r instanceof Rational)) r = new Rational(r);
				return new Rational(this.num * r.den + r.num * this.den, this.den * r.den);
			}
			
			sub(r) {
				if (!(r instanceof Rational)) r = new Rational(r);
				return new Rational(this.num * r.den - r.num * this.den, this.den * r.den);
			}
			
			mul(r) {
				if (!(r instanceof Rational)) r = new Rational(r);
				return new Rational(this.num * r.num, this.den * r.den);
			}
			
			div(r) {
				if (!(r instanceof Rational)) r = new Rational(r);
				return new Rational(this.num * r.den, this.den * r.num);
			}
			
			toString() {
				if (this.den === 1) return this.num.toString();
				return this.num + '/' + this.den;
			}
		}
		
		// Radical: exact form a₀ + a₁√2 + a₂√3 + a₃√5 + ...
		// Stored as a map: { radicand -> Rational coefficient }
		class Radical {
			constructor(coeffs = {}) {
				this.coeffs = {};
				for (let k in coeffs) {
					if (coeffs[k].num !== 0) {
						this.coeffs[k] = coeffs[k];
					}
				}
			}
			
			static of(n) {
				if (typeof n === 'number') n = new Rational(n);
				const r = new Radical();
				r.coeffs[1] = n instanceof Rational ? n : new Rational(n);
				return r;
			}
			
			add(r) {
				const result = new Radical(this.coeffs);
				for (let k in r.coeffs) {
					result.coeffs[k] = (result.coeffs[k] || new Rational(0)).add(r.coeffs[k]);
					if (result.coeffs[k].num === 0) delete result.coeffs[k];
				}
				return result;
			}
			
			sub(r) {
				const result = new Radical(this.coeffs);
				for (let k in r.coeffs) {
					result.coeffs[k] = (result.coeffs[k] || new Rational(0)).sub(r.coeffs[k]);
					if (result.coeffs[k].num === 0) delete result.coeffs[k];
				}
				return result;
			}
			
			mul(r) {
				if (!(r instanceof Radical)) r = Radical.of(r);
				const result = new Radical();
				
				for (let k1 in this.coeffs) {
					for (let k2 in r.coeffs) {
						const radicand_and_coeff = multiplyRadicands(parseInt(k1), parseInt(k2));
						const radicand = radicand_and_coeff.radicand;
						const outer_coeff = radicand_and_coeff.coeff;
						
						const coeff = this.coeffs[k1].mul(r.coeffs[k2]).mul(outer_coeff);
						result.coeffs[radicand] = (result.coeffs[radicand] || new Rational(0)).add(coeff);
						if (result.coeffs[radicand].num === 0) delete result.coeffs[radicand];
					}
				}
				return result;
			}
			
			div(r) {
				if (!(r instanceof Radical)) r = Radical.of(r);
				
				// Rationalize: multiply by conjugate of denominator
				const denom_keys = Object.keys(r.coeffs).map(x => parseInt(x)).sort();
				
				if (denom_keys.length === 1 && denom_keys[0] === 1) {
					// Denominator is just a rational number
					const denom_rational = r.coeffs[1];
					const result = new Radical();
					for (let k in this.coeffs) {
						result.coeffs[k] = this.coeffs[k].div(denom_rational);
					}
					return result;
				}
				
				if (denom_keys.length === 1 && denom_keys[0] !== 1) {
					// Denominator is just a radical like √n with no integer part
					// Conjugate of √n is √n (same), so multiply by √n
					const radical_key = denom_keys[0];
					const coeff = r.coeffs[radical_key];
					
					// Multiply numerator and denominator by √n
					const sqrtn = new Radical();
					sqrtn.coeffs[radical_key] = new Rational(1);
					
					const new_num = this.mul(sqrtn);
					const new_den = r.mul(sqrtn);
					
					// new_den should now be rational (√n * √n = n)
					const den_coeff = new_den.coeffs[1];
					const result = new Radical();
					for (let k in new_num.coeffs) {
						result.coeffs[k] = new_num.coeffs[k].div(den_coeff);
					}
					return result;
				}
				
				if (denom_keys.length === 2 && denom_keys[0] === 1) {
					// Denominator like a + b√n, conjugate is a - b√n
					const radical_key = denom_keys[1];
					const a = r.coeffs[1];
					const b = r.coeffs[radical_key];
					
					// Multiply numerator and denominator by conjugate
					const conj = new Radical();
					conj.coeffs[1] = a;
					conj.coeffs[radical_key] = b.mul(new Rational(-1));
					
					const new_num = this.mul(conj);
					const new_den = r.mul(conj);
					
					// new_den should now be rational
					const den_coeff = new_den.coeffs[1];
					const result = new Radical();
					for (let k in new_num.coeffs) {
						result.coeffs[k] = new_num.coeffs[k].div(den_coeff);
					}
					return result;
				}
				
				throw new Error('Cannot divide: complex denominator');
			}
			
			pow(n) {
				if (n === 0) return Radical.of(1);
				if (n === 1) return new Radical(this.coeffs);
				if (n < 0) return Radical.of(1).div(this.pow(-n));
				if (n > 10) throw new Error('Exponent too large (max 10)');
				
				let result = Radical.of(1);
				for (let i = 0; i < n; i++) {
					result = result.mul(this);
				}
				return result;
			}
			
			toLatex() {
				const keys = Object.keys(this.coeffs).map(k => parseInt(k)).sort((a, b) => a - b);
				if (keys.length === 0) return '0';
				
				let parts = [];
				for (let k of keys) {
					const c = this.coeffs[k];
					const isNeg = c.num < 0;
					const absNum = Math.abs(c.num);
					const cStr = c.den === 1 ? absNum.toString() : '\\frac{' + absNum + '}{' + c.den + '}';
					
					if (k === 1) {
						parts.push(isNeg ? '-' + cStr : cStr);
					} else {
						const radical = k === 2 ? '\\sqrt{2}' : k === 3 ? '\\sqrt{3}' : k === 5 ? '\\sqrt{5}' : '\\sqrt{' + k + '}';
						if (absNum === 1 && c.den === 1) {
							parts.push(isNeg ? '-' + radical : radical);
						} else {
							parts.push((isNeg ? '-' : '') + cStr + radical);
						}
					}
				}
				
				let result = parts[0];
				for (let i = 1; i < parts.length; i++) {
					if (parts[i][0] === '-') {
						result += parts[i];
					} else {
						result += '+' + parts[i];
					}
				}
				return result;
			}
		}
		
		function multiplyRadicands(a, b) {
			// √a * √b = √(ab), then simplify
			// Returns { radicand: simplified_radicand, coeff: extracted_perfect_square }
			// So √a * √b = coeff * √radicand
			let prod = a * b;
			let simplified = 1;
			for (let i = 2; i * i <= prod; i++) {
				while (prod % (i * i) === 0) {
					simplified *= i;
					prod /= i * i;
				}
			}
			// Now prod = inner radicand (after simplification), simplified = coefficient
			return { radicand: prod, coeff: new Rational(simplified) };
		}
		
		function parseLatex(latex) {
			latex = latex.replace(/\s+/g, '');
			return parseExpression(latex, 0).value;
		}
		
		function parseExpression(latex, pos) {
			let left = parseTerm(latex, pos);
			pos = left.pos;
			
			while (pos < latex.length && (latex[pos] === '+' || latex[pos] === '-')) {
				const op = latex[pos];
				pos++;
				const right = parseTerm(latex, pos);
				pos = right.pos;
				left.value = op === '+' ? 
					RationalFunction.of(left.value).add(RationalFunction.of(right.value)) :
					RationalFunction.of(left.value).sub(RationalFunction.of(right.value));
			}
			
			return { value: left.value, pos };
		}
				function parseTerm(latex, pos) {
			let left = parseFactor(latex, pos);
			pos = left.pos;
			
			while (pos < latex.length) {
				// Check for explicit multiplication operators
				if (latex[pos] === '*' || latex.substr(pos, 5) === '\\cdot') {
					if (latex[pos] === '\\') pos += 5;
					else pos++;
					const right = parseFactor(latex, pos);
					pos = right.pos;
					left.value = RationalFunction.of(left.value).mul(RationalFunction.of(right.value));
				}
				// Check for implicit multiplication (next char is \ or ( or digit)
				else if (pos < latex.length && (latex[pos] === '\\' || latex[pos] === '(' || /\d/.test(latex[pos]))) {
					const right = parseFactor(latex, pos);
					pos = right.pos;
					left.value = RationalFunction.of(left.value).mul(RationalFunction.of(right.value));
				}
				else {
					break;
				}
			}
			
			return { value: left.value, pos };
		}
		
		function parseFactor(latex, pos) {
			// Handle unary minus
			let negate = false;
			if (pos < latex.length && latex[pos] === '-') {
				negate = true;
				pos++;
			}
			
			let base = parsePrimary(latex, pos);
			pos = base.pos;
			
			if (negate) {
				base.value = RationalFunction.of(base.value).mul(RationalFunction.of(AlgebraicExpr.ofNumber(-1)));
			}
			
			if (pos < latex.length && latex[pos] === '^') {
				pos++;
				let exp = '';
				if (latex[pos] === '{') {
					pos++;
					let depth = 1;
					while (depth > 0 && pos < latex.length) {
						if (latex[pos] === '{') depth++;
						else if (latex[pos] === '}') depth--;
						if (depth > 0) exp += latex[pos];
						pos++;
					}
				} else {
					exp = latex[pos];
					pos++;
				}
				
				// Parse exponent
				if (exp.includes('\\frac')) {
					// Handle \frac{num}{den} format
					const fracMatch = exp.match(/\\frac\{(\d+)\}\{(\d+)\}/);
					if (fracMatch) {
						const num = parseInt(fracMatch[1]);
						const den = parseInt(fracMatch[2]);
						if (den === 2) {
							// base.value = sqrtRadical(base.value); // TODO: implement for AlgebraicExpr
							if (num !== 1) base.value = RationalFunction.of(base.value).pow(num);
						} else {
							throw new Error('Fractional exponents other than 1/2 not supported');
						}
					} else {
						throw new Error('Cannot parse fractional exponent: ' + exp);
					}
				} else if (exp.includes('/')) {
					const [num, den] = exp.split('/').map(x => parseInt(x));
					if (den === 2) {
						// base.value = sqrtRadical(base.value); // TODO: implement for AlgebraicExpr
						if (num !== 1) base.value = RationalFunction.of(base.value).pow(num);
					} else {
						throw new Error('Fractional exponents other than 1/2 not supported');
					}
				} else {
					const n = parseInt(exp);
					base.value = RationalFunction.of(base.value).pow(n);
				}
			}
			
			return { value: base.value, pos };
		}
		
		function parsePrimary(latex, pos) {
			if (pos < latex.length && latex[pos] === '\\') {
				// Handle \left( ... \right)
				if (latex.substr(pos, 5) === '\\left') {
					pos += 5;
					if (pos < latex.length && latex[pos] === '(') {
						pos++; // skip the (
						// Find matching \right)
						let depth = 1;
						let exprStart = pos;
						while (depth > 0 && pos < latex.length) {
							if (latex.substr(pos, 6) === '\\left(') {
								depth++;
								pos += 6;
							} else if (latex.substr(pos, 6) === '\\right') {
								depth--;
								if (depth === 0) break;
								pos += 6;
							} else {
								pos++;
							}
						}
						const exprStr = latex.substring(exprStart, pos);
						if (latex.substr(pos, 6) === '\\right') pos += 6;
						if (pos < latex.length && latex[pos] === ')') pos++;
						const expr = parseExpression(exprStr, 0).value;
						return { value: expr, pos };
					}
				}
				
				if (latex.substr(pos, 5) === '\\frac') {
					let depth = 0, endPos = pos + 5;
					let numPart = '';
					// Find {numerator}
					endPos++;
					depth = 1;
					while (depth > 0) {
						numPart += latex[endPos];
						if (latex[endPos] === '{') depth++;
						else if (latex[endPos] === '}') depth--;
						endPos++;
					}
					numPart = numPart.slice(0, -1);
					
					let denPart = '';
					endPos++;
					depth = 1;
					while (depth > 0) {
						denPart += latex[endPos];
						if (latex[endPos] === '{') depth++;
						else if (latex[endPos] === '}') depth--;
						endPos++;
					}
					denPart = denPart.slice(0, -1);
					
					const num = parseExpression(numPart, 0).value;
					const den = parseExpression(denPart, 0).value;
					
					// Convert both to RationalFunction if needed
					const numRat = RationalFunction.of(num);
					const denRat = RationalFunction.of(den);
					
					// Divide: numRat / denRat = numRat * (1 / denRat) = numRat * (denRat.denominator / denRat.numerator)
					const invDen = new RationalFunction(denRat.denominator, denRat.numerator);
					return { value: numRat.mul(invDen), pos: endPos };
				} else if (latex.substr(pos, 5) === '\\sqrt') {
					let depth = 0, endPos = pos + 6;
					let inner = '';
					depth = 1;
					while (depth > 0) {
						inner += latex[endPos];
						if (latex[endPos] === '{') depth++;
						else if (latex[endPos] === '}') depth--;
						endPos++;
					}
					inner = inner.slice(0, -1);
					const rad = parseExpression(inner, 0).value;
					return { value: sqrtRadical(rad), pos: endPos };
				}
			}
			
			if (pos < latex.length && latex[pos] === '(') {
				const expr = parseExpression(latex, pos + 1);
				return { value: expr.value, pos: expr.pos + 1 };
			}
			
			const m = /^\d+/.exec(latex.substr(pos));
			if (m) {
				return { value: AlgebraicExpr.ofNumber(parseInt(m[0])), pos: pos + m[0].length };
			}
			
			// Handle variables like x, y, z
			const varMatch = /^[a-z]/.exec(latex.substr(pos));
			if (varMatch) {
				const varName = varMatch[0];
				return { value: AlgebraicExpr.ofVariable(varName), pos: pos + 1 };
			}
			
			throw new Error('Cannot parse at: ' + latex.substr(pos, 20));
		}
		
		function sqrtRadical(r) {
			// √(a + b√c + ...) is complex; for simple integers:
			if (Object.keys(r.coeffs).length === 1 && r.coeffs[1]) {
				const n = r.coeffs[1].num;
				const d = r.coeffs[1].den;
				if (d !== 1) throw new Error('Cannot take square root of non-integer');
				
				if (n < 0) throw new Error('Cannot take square root of negative');
				
				// √n: factor out perfect squares
				let simplified = 1;
				let under = n;
				for (let i = 2; i * i <= under; i++) {
					while (under % (i * i) === 0) {
						simplified *= i;
						under /= i * i;
					}
				}
				
				const result = new Radical();
				result.coeffs[under] = new Rational(simplified);
				return result;
			}
			throw new Error('Cannot take square root of complex radical');
		}
		
		function radicalToDecimal(radical) {
			let sum = 0;
			for (let k in radical.coeffs) {
				const coeff = radical.coeffs[k];
				const decimalCoeff = coeff.num / coeff.den;
				if (k === '1') {
					sum += decimalCoeff;
				} else {
					sum += decimalCoeff * Math.sqrt(parseInt(k));
				}
			}
			return sum;
		}
		
		function algebraicToDecimal(expr) {
			// For expressions with variables, we can't compute a single decimal value
			// Return NaN or 0, or we could evaluate at specific variable values
			// For now, return 0 for expressions with variables
			if (expr instanceof RationalFunction) {
				// Try to evaluate as decimal if possible
				if (expr.denominator.isConstant()) {
					const numDec = algebraicToDecimal(expr.numerator);
					const denDec = algebraicToDecimal(expr.denominator);
					if (denDec !== 0) return numDec / denDec;
				}
				return 0;
			}
			if (expr instanceof AlgebraicExpr) {
				if (!expr.isConstant()) {
					return 0; // Cannot evaluate expressions with variables
				}
				const constCoeff = expr.terms.constant && expr.terms.constant[0];
				if (constCoeff) {
					return constCoeff.num / constCoeff.den;
				}
			}
			return 0;
		}
	</script>

</body>
</html>
